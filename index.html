<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#1c1b22">
  <link id="page-favicon" rel="icon" /><script>document.getElementById('page-favicon').href='data:image/svg+xml,'+encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">ðŸ”´</text></svg>');</script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>00:05</title>

  <style>
    :root {
      --bg:     #1c1b22;
      --card:   #2b2a32;
      --card2:  #27262e;
      --text:   #e5e5e5;
      --dim:    #7c7884;
      --accent: #757c58;
      --radius: 12px;
    }

    body {
      margin: 0;
      background: var(--bg);
      font-family: Inter, Arial, sans-serif;
      color: var(--text);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 40px;
      margin-top: clamp(12px, 6vh, 100px);
    }

    .page-wrap { width: 80%; max-width: 950px; margin: 0 auto; }

    #session-label {
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--dim);
      width: 80%;
      max-width: 950px;
      margin: 0 0 2px;
      line-height: 1;
    }

    #timer-row {
      display: flex;
      align-items: baseline;
      gap: 16px;
      width: 80%;
      max-width: 950px;
      margin: 0 0 28px;
    }

    #countdown {
      font-size: 4.5rem;
      font-weight: 600;
      letter-spacing: -3px;
      line-height: 1;
      flex-shrink: 0;
      font-variant-numeric: tabular-nums;
      cursor: pointer;
      user-select: none;
    }

    #label-input {
      flex: 1;
      min-width: 0;
      background: transparent;
      border: none;
      outline: none;
      font-family: Inter, Arial, sans-serif;
      font-size: 4.5rem;
      font-weight: 600;
      letter-spacing: -3px;
      color: var(--dim);
      padding: 0;
      line-height: 1;
      padding-bottom: 0.15em;
      caret-color: var(--dim);
      resize: none;
      overflow: hidden;
      word-break: break-word;
      -webkit-appearance: none;
      appearance: none;
    }

    #label-input::placeholder { color: rgba(255,255,255,0.01); }
    #label-input:focus::placeholder { opacity: 0; }

    #tomato-row {
      width: 100%;
      margin: 0 0 28px;
      font-size: 1.4rem;
      line-height: 1.6;
      min-height: 2.25rem;
    }
    #tomato-row.detail-open { margin-bottom: 6px; }

    .tomato { cursor: pointer; padding: 2px; border-radius: 4px; line-height: 0; display: inline-block; vertical-align: bottom; }
    .tomato.active { background: var(--card); }
    .tomato svg { width: 1.2em; height: 1.2em; display: block; }
    #pomo-detail svg { width: 1em; height: 1em; display: inline-block; vertical-align: middle; }

    #pomo-detail {
      display: none;
      background: var(--card);
      border-radius: var(--radius);
      padding: 10px 14px;
      margin-bottom: 22px;
      font-size: 0.78rem;
      color: var(--dim);
      line-height: 1.7;
    }
    #pomo-detail.visible { display: block; }
    #pomo-detail .detail-label { color: var(--text); font-weight: 500; }

    .instructions {
      color: var(--dim);
      font-size: 0.72rem;
      line-height: 1.9;
    }

    kbd {
      background: #18171e;
      color: #b6b3bc;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.7rem;
      font-family: Inter, monospace;
    }

    .reset-btn {
      background: none;
      border: none;
      color: var(--dim);
      font-family: Inter, sans-serif;
      font-size: 0.72rem;
      cursor: pointer;
      padding: 0;
    }
    .reset-btn:hover { color: var(--text); }

    /* â”€â”€ Timer modal â”€â”€ */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    .modal-overlay.visible { display: flex; }

    .modal {
      background: var(--card);
      border-radius: var(--radius);
      padding: 28px 32px;
      width: fit-content;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    }

    .modal-title {
      margin: 0 0 20px;
      font-size: 1rem;
      font-weight: 600;
      color: var(--text);
    }

    .modal-row {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 20px;
    }

    .modal-field { flex: 1; }

    .modal-field label {
      display: block;
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.07em;
      text-transform: uppercase;
      color: var(--dim);
      margin-bottom: 6px;
    }

    .modal-field input {
      width: 100%;
      background: var(--card2);
      border: 1px solid #44435a;
      border-radius: 8px;
      padding: 9px 12px;
      font-size: 0.9rem;
      font-family: Inter, sans-serif;
      color: var(--text);
      outline: none;
      box-sizing: border-box;
    }
    .modal-field input:focus { border-color: var(--accent); }

    .modal-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .modal-actions button {
      background: var(--card2);
      border: 1px solid #44435a;
      border-radius: 8px;
      padding: 9px 20px;
      font-size: 0.88rem;
      font-family: Inter, sans-serif;
      color: var(--text);
      cursor: pointer;
    }
    .modal-actions button:hover { border-color: var(--accent); }

    .modal-actions .modal-save-btn {
      background: #a8b86a;
      border-color: #a8b86a;
      color: #1c1b22;
      font-weight: 600;
    }
    .modal-actions .modal-save-btn:hover { background: #bccf7a; border-color: #bccf7a; color: #0e0d14; }

    /* â”€â”€ Workout modal â”€â”€ */
    #workout-modal .modal { min-width: 320px; }
    .workout-task-row { display: flex; gap: 8px; margin-bottom: 8px; }
    .workout-task-row input {
      flex: 1;
      background: var(--card2);
      border: 1px solid #44435a;
      border-radius: 8px;
      padding: 9px 12px;
      font-size: 0.9rem;
      font-family: Inter, sans-serif;
      color: var(--text);
      outline: none;
      box-sizing: border-box;
    }
    .workout-task-row input:focus { border-color: var(--accent); }
    .workout-task-remove {
      background: none;
      border: 1px solid #44435a;
      border-radius: 8px;
      padding: 9px 12px;
      font-size: 0.9rem;
      font-family: Inter, sans-serif;
      color: var(--dim);
      cursor: pointer;
    }
    .workout-task-remove:hover { border-color: var(--accent); color: var(--text); }
    #workout-add-btn {
      display: block;
      background: none;
      border: none;
      color: var(--dim);
      font-family: Inter, sans-serif;
      font-size: 0.85rem;
      cursor: pointer;
      padding: 4px 0;
    }
    #workout-add-btn:hover { color: var(--text); }
    #workout-summary { font-size: 0.75rem; color: var(--dim); margin: 12px 0 4px; }
    .workout-toggle { display: flex; align-items: center; gap: 7px; margin: 10px 0 0; font-size: 0.82rem; color: var(--dim); cursor: pointer; user-select: none; }
    .workout-toggle input[type="checkbox"] { accent-color: var(--accent); width: 13px; height: 13px; cursor: pointer; margin: 0; }

    /* â”€â”€ Narrow screens: stack label below timer â”€â”€ */
    @media (max-width: 540px) {
      #timer-row { display: block; }
      #label-input { display: block; width: 100%; box-sizing: border-box; font-size: 2rem; letter-spacing: -1px; }
    }

    /* â”€â”€ GitHub link â”€â”€ */
    .gh-link {
      position: fixed;
      bottom: 14px;
      right: 18px;
      font-size: 0.68rem;
      color: var(--dim);
      text-decoration: none;
      opacity: 0.45;
      transition: opacity 0.15s;
    }
    .gh-link:hover { opacity: 1; }
  </style>
</head>

<body>

  <div id="session-label">focus</div>
  <div id="timer-row">
    <div id="countdown">00:05</div>
    <textarea id="label-input" autocomplete="off" spellcheck="false" placeholder="â–Œ" rows="1"></textarea>
  </div>

  <div class="page-wrap">
    <div id="tomato-row"></div>
    <div id="pomo-detail"></div>
    <div class="instructions">
      <button class="reset-btn" id="btn-playpause"><kbd>Space</kbd> start/pause</button> &nbsp;Â·&nbsp;
      <button class="reset-btn" id="btn-skip"><kbd>s</kbd> skip</button> &nbsp;Â·&nbsp;
      <button class="reset-btn" id="btn-reset"><kbd>r</kbd> reset</button> &nbsp;Â·&nbsp;
      <button class="reset-btn" id="btn-label"><kbd>â†µ</kbd> edit label</button> &nbsp;Â·&nbsp;
      <button class="reset-btn" id="btn-clearlabel"><kbd>del</kbd> clear label</button><br>
      <button class="reset-btn" id="btn-export"><kbd>e</kbd> export</button> &nbsp;Â·&nbsp;
      <button class="reset-btn" id="btn-clearlog"><kbd>c</kbd> clear log</button> &nbsp;Â·&nbsp;
      <button class="reset-btn" id="btn-durations"><kbd>d</kbd> durations</button> &nbsp;Â·&nbsp;
      <button class="reset-btn" id="autostart-btn">auto-start: breaks</button> &nbsp;Â·&nbsp;
      <button class="reset-btn" id="btn-sound"><kbd>m</kbd> sound: on</button><br>
      <button class="reset-btn" id="btn-fullscreen"><kbd>f</kbd> fullscreen</button> &nbsp;Â·&nbsp;
      <button class="reset-btn" id="btn-logbreaks"><kbd>b</kbd> log breaks: off</button> &nbsp;Â·&nbsp;
      <button class="reset-btn" id="btn-workout"><kbd>w</kbd> workout: off</button>
    </div>
  </div>

  <div class="modal-overlay" id="timer-modal">
    <div class="modal">
      <p class="modal-title">Set durations</p>
      <div class="modal-row">
        <div class="modal-field">
          <label for="focus-input">Focus</label>
          <input id="focus-input" type="text" placeholder="25:00" />
        </div>
        <div class="modal-field">
          <label for="break-input">Break</label>
          <input id="break-input" type="text" placeholder="05:00" />
        </div>
        <div class="modal-field">
          <label for="longbreak-input">Long break</label>
          <div style="display:flex;gap:8px;align-items:center;">
            <input id="longbreak-input" type="text" placeholder="â€”" style="flex:1;min-width:0;" />
            <span style="font-size:0.75rem;color:var(--dim);white-space:nowrap;">every</span>
            <input id="longbreak-freq-input" type="text" placeholder="4" style="width:44px;" />
            <span style="font-size:0.75rem;color:var(--dim);">breaks</span>
          </div>
        </div>
      </div>
      <div class="modal-actions">
        <button id="modal-reset">Reset</button>
        <button id="modal-cancel">Cancel</button>
        <button class="modal-save-btn" id="modal-save">Set</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="workout-modal">
    <div class="modal">
      <p class="modal-title">Workout exercises</p>
      <div id="workout-task-list"></div>
      <button id="workout-add-btn">+ add exercise</button>
      <label class="workout-toggle">
        <input type="checkbox" id="workout-no-longbreak-check"> disable long breaks
      </label>
      <p id="workout-summary"></p>
      <div class="modal-actions">
        <button id="workout-deactivate">Deactivate</button>
        <button id="workout-cancel">Cancel</button>
        <button class="modal-save-btn" id="workout-save">Save</button>
      </div>
    </div>
  </div>

  <a class="gh-link" href="https://github.com/moltaire/pomodoro" target="_blank" rel="noopener">github</a>

<script>

/* â”€â”€ Bauhaus log icons â”€â”€ */
const SVG_CIRCLE      = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><circle cx="8" cy="8" r="7.5" fill="#CE3F32"/></svg>';
const SVG_HALF_CIRCLE = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M8,0.5 A7.5,7.5 0 0,0 8,15.5 Z" fill="#F4BA40"/></svg>';
const SVG_SQUARE      = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><rect x="1.2" y="1.2" width="13.6" height="13.6" fill="#2A62B6"/></svg>';

/* â”€â”€ emoji favicon (dynamic switching for Firefox/Chrome; initial ðŸŸ¥ set in <head>) â”€â”€ */
const _faviconLink = document.getElementById('page-favicon');
function _setFaviconEmoji(emoji) {
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">${emoji}</text></svg>`;
  _faviconLink.href = 'data:image/svg+xml,' + encodeURIComponent(svg);
}

let focusSecs     = 25 * 60;
let breakSecs     = 5  * 60;
let longBreakSecs  = 20 * 60; // null = disabled
let longBreakFreq  = 4;       // every Nth break; 0 = disabled

/* â”€â”€ Sound â”€â”€ */
let soundMode = 'on';  // 'on' | 'finish' | 'off'
let audioCtx  = null;

function getAudioCtx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

/* iOS Safari keeps AudioContext suspended until a user gesture explicitly resumes it.
   Create the context here (not lazily on first sound) so that the very first tap/key
   both creates AND unlocks it while we're still inside the user-gesture callback.
   Also play a silent <Audio> element once to promote the iOS audio session from
   "ambient" (respects mute switch) to "playback" (ignores mute switch). */
let _iosAudioUnlocked = false;
function resumeAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
  if (!_iosAudioUnlocked) {
    _iosAudioUnlocked = true;
    const a = new Audio('data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=');
    a.play().catch(() => {});
  }
}

/* Metronome tick: short noise burst with power-law decay (~20 ms) */
function playTick() {
  const ctx  = getAudioCtx();
  const len  = Math.floor(ctx.sampleRate * 0.02);
  const buf  = ctx.createBuffer(1, len, ctx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < len; i++)
    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 6);
  const src  = ctx.createBufferSource();
  const gain = ctx.createGain();
  gain.gain.value = 0.35;
  src.buffer = buf;
  src.connect(gain);
  gain.connect(ctx.destination);
  src.start();
}

/* Session-end clave: two quick sine taps at 1400 / 1600 Hz */
function playDone() {
  const ctx = getAudioCtx();
  [0, 0.08].forEach((offset, i) => {
    const osc  = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.frequency.value = 1400 + i * 200;
    const t = ctx.currentTime + offset;
    gain.gain.setValueAtTime(0.4, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.07);
    osc.start(t);
    osc.stop(t + 0.07);
  });
}

/* â”€â”€ State â”€â”€ */
let isFocus          = true;
let isLongBreak      = false;
let secondsLeft      = focusSecs;
let isRunning        = false;
let timerId          = null;
let sessionStartTime = null; // ISO string, set when a focus session begins
let breakStartTime   = null; // ISO string, set when a break timer begins
let autoStartMode    = 'breaks'; // 'off' | 'breaks' | 'on'
let logBreaks        = false;
let log              = [];
// log entry: { label: string|null, startedAt: ISO|null, endedAt: ISO, durationSecs: number }
let workoutMode        = false;
let workoutTasks       = [];   // string[], persisted
let workoutIndex       = 0;    // runtime only
let workoutNoLongBreak = true; // persisted
let focusSessionCount  = 0;    // persisted; drives long break frequency

/* â”€â”€ localStorage â”€â”€ */
function lsGet(k) { try { return localStorage.getItem(k); } catch { return null; } }
function lsSet(k, v) { try { localStorage.setItem(k, v); } catch {} }

function saveLog()        { lsSet('pomo_log2',           JSON.stringify(log)); }
function saveLabel()      { lsSet('pomo_label',           labelInput.value); }
function saveAutoStart()  { lsSet('pomo_autostart',       autoStartMode); }
function saveSound()      { lsSet('pomo_sound',           soundMode); }
function saveLogBreaks()    { lsSet('pomo_log_breaks',      logBreaks ? '1' : ''); }
function saveWorkoutTasks()       { lsSet('pomo_workout_tasks',        JSON.stringify(workoutTasks)); }
function saveWorkoutMode()        { lsSet('pomo_workout_mode',         workoutMode ? '1' : ''); }
function saveWorkoutNoLongBreak() { lsSet('pomo_workout_no_longbreak', workoutNoLongBreak ? '1' : ''); }
function saveFocusCount()         { lsSet('pomo_focus_count',          String(focusSessionCount)); }
function saveDurations() {
  lsSet('pomo_focus_secs',      String(focusSecs));
  lsSet('pomo_break_secs',      String(breakSecs));
  lsSet('pomo_long_break_secs', longBreakSecs !== null ? String(longBreakSecs) : '');
  lsSet('pomo_long_break_freq', String(longBreakFreq));
}

function loadLog() {
  try { log = JSON.parse(lsGet('pomo_log2')) || []; } catch { log = []; }
}
function loadLabel() {
  labelInput.value = lsGet('pomo_label') || '';
  resizeLabelInput();
}
function loadAutoStart() {
  const v = lsGet('pomo_autostart');
  autoStartMode = (v === 'on' || v === 'off' || v === 'breaks') ? v : 'breaks';
}
function loadSound() {
  const v = lsGet('pomo_sound');
  soundMode = (v === 'finish' || v === 'off') ? v : 'on';
}
function loadLogBreaks() {
  logBreaks = lsGet('pomo_log_breaks') === '1';
}
function loadWorkoutTasks() {
  try { workoutTasks = JSON.parse(lsGet('pomo_workout_tasks')) || []; } catch { workoutTasks = []; }
}
function loadWorkoutMode() {
  workoutMode = lsGet('pomo_workout_mode') === '1';
}
function loadWorkoutNoLongBreak() {
  const v = lsGet('pomo_workout_no_longbreak');
  workoutNoLongBreak = v === null ? true : v === '1'; // default true
}
function loadFocusCount() {
  const v = parseInt(lsGet('pomo_focus_count'), 10);
  if (!isNaN(v) && v >= 0) focusSessionCount = v;
}
function loadDurations() {
  const f   = parseInt(lsGet('pomo_focus_secs'),      10);
  const b   = parseInt(lsGet('pomo_break_secs'),      10);
  const lb  = parseInt(lsGet('pomo_long_break_secs'), 10);
  const lbf = parseInt(lsGet('pomo_long_break_freq'), 10);
  if (!isNaN(f)   && f   > 0)  focusSecs     = f;
  if (!isNaN(b)   && b   > 0)  breakSecs     = b;
  if (!isNaN(lb)  && lb  > 0)  longBreakSecs = lb;
  if (!isNaN(lbf) && lbf >= 0) longBreakFreq = lbf;
}

/* â”€â”€ Timer â€” setTimeout-based for reliability â”€â”€ */
function start() {
  if (isRunning) return;
  /* record when this session begins (first start, not resume) */
  if (isFocus && sessionStartTime === null) {
    sessionStartTime = new Date().toISOString();
    if (workoutMode && workoutTasks.length) {
      labelInput.value = workoutTasks[workoutIndex] ?? '';
      resizeLabelInput(); saveLabel();
    }
  }
  if (!isFocus && breakStartTime === null) {
    breakStartTime = new Date().toISOString();
  }
  isRunning = true;
  timerId   = setTimeout(tick, 1000);
}

function pause() {
  if (!isRunning) return;
  isRunning = false;
  clearTimeout(timerId);
  timerId = null;
}

function tick() {
  if (!isRunning) return;
  secondsLeft--;
  if (soundMode === 'on' && isFocus) playTick();
  renderCountdown();
  updateTitle();
  if (secondsLeft <= 0) {
    onSessionEnd();
  } else {
    timerId = setTimeout(tick, 1000);
  }
}

function onSessionEnd() {
  isRunning = false;
  timerId   = null;
  if (soundMode === 'on' || soundMode === 'finish') playDone();

  if (isFocus) {
    const endedAt = new Date().toISOString();
    log.push({
      label:       labelInput.value.trim() || null,
      startedAt:   sessionStartTime,
      endedAt,
      durationSecs: focusSecs,
    });
    sessionStartTime = null;
    focusSessionCount++;
    saveFocusCount();
    saveLog();
    renderLog();
  } else {
    if (logBreaks) {
      const endedAt = new Date().toISOString();
      log.push({
        type:        'break',
        startedAt:   breakStartTime,
        endedAt,
        durationSecs: isLongBreak ? longBreakSecs : breakSecs,
      });
      saveLog();
      renderLog();
    }
    breakStartTime = null;
    if (workoutMode) {
      if (workoutIndex >= workoutTasks.length - 1) {
        workoutComplete(); return;
      }
      workoutIndex++;
    }
  }

  isFocus = !isFocus;

  if (!isFocus) {
    /* entering a break â€” long break every N focus sessions */
    isLongBreak = longBreakSecs !== null && longBreakFreq > 0
      && focusSessionCount % longBreakFreq === 0
      && !(workoutMode && workoutNoLongBreak);
    if (workoutMode) {
      const next = workoutTasks[workoutIndex + 1];
      labelInput.value = next ? 'Next:\n' + next : '';
      resizeLabelInput(); saveLabel();
    }
    secondsLeft = isLongBreak ? longBreakSecs : breakSecs;
  } else {
    isLongBreak = false;
    secondsLeft = focusSecs;
  }

  renderSessionLabel();
  renderCountdown();
  updateTitle();

  /* auto-start: workout always auto-starts; 'on' always; 'breaks' only on break */
  const entering = isFocus ? 'focus' : 'break';
  const shouldStart = workoutMode
    || autoStartMode === 'on'
    || (autoStartMode === 'breaks' && entering === 'break');
  if (shouldStart) {
    setTimeout(start, 100);
  }
}

function reset() {
  pause();
  sessionStartTime = null;
  breakStartTime   = null;
  secondsLeft = isFocus ? focusSecs : (isLongBreak ? longBreakSecs : breakSecs);
  if (workoutMode && workoutTasks.length) {
    workoutIndex = 0;
    isFocus = true;
    secondsLeft = focusSecs;
    labelInput.value = workoutTasks[0];
    resizeLabelInput(); saveLabel();
    renderSessionLabel();
  }
  renderCountdown();
  updateTitle();
}

function skip() {
  const wasRunning = isRunning;
  pause();

  /* log skipped focus session (peach) if it was actually started */
  if (isFocus && sessionStartTime !== null) {
    const endedAt = new Date().toISOString();
    log.push({
      label:       labelInput.value.trim() || null,
      startedAt:   sessionStartTime,
      endedAt,
      durationSecs: focusSecs - secondsLeft,
      skipped:     true,
    });
    saveLog();
    renderLog();
  }

  sessionStartTime = null;
  breakStartTime   = null;
  if (isFocus) {
    focusSessionCount++;
    saveFocusCount();
  }
  if (workoutMode && !isFocus) {
    if (workoutIndex >= workoutTasks.length - 1) { workoutComplete(); return; }
    workoutIndex++;
  }
  isFocus     = !isFocus;
  isLongBreak = !isFocus && longBreakSecs !== null && longBreakFreq > 0
    && focusSessionCount % longBreakFreq === 0
    && !(workoutMode && workoutNoLongBreak);
  secondsLeft = isFocus ? focusSecs : (isLongBreak ? longBreakSecs : breakSecs);
  if (!isFocus && workoutMode) {
    const next = workoutTasks[workoutIndex + 1];
    labelInput.value = next ? 'Next:\n' + next : '';
    resizeLabelInput(); saveLabel();
  }
  renderSessionLabel();
  renderCountdown();
  updateTitle();
  const entering = isFocus ? 'focus' : 'break';
  if (wasRunning || autoStartMode === 'on' || (autoStartMode === 'breaks' && entering === 'break')) {
    start();
  }
}

/* â”€â”€ Render â”€â”€ */
function renderSessionLabel() {
  const el = document.getElementById('session-label');
  if (workoutMode && workoutTasks.length) {
    const n = (workoutIndex + 1) + '/' + workoutTasks.length;
    el.textContent = isFocus ? n + ' Â· Workout' : n + ' Â· Rest';
  } else if (isFocus) {
    el.textContent = 'focus';
  } else if (isLongBreak) {
    el.textContent = 'long break';
  } else {
    el.textContent = 'break';
  }
}

function renderCountdown() {
  const m = Math.floor(secondsLeft / 60);
  const s = secondsLeft % 60;
  document.getElementById('countdown').textContent =
    String(m).padStart(2, '0') + ':' + String(s).padStart(2, '0');
}

function updateTitle() {
  const m = Math.floor(secondsLeft / 60);
  const s = secondsLeft % 60;
  const t = String(m).padStart(2, '0') + ':' + String(s).padStart(2, '0');
  document.title = t;
  _setFaviconEmoji(isFocus ? 'ðŸ”´' : 'ðŸŸ¦');
}

/* â”€â”€ Pomo detail panel â”€â”€ */
let detailIndex = null;

function fmtDur(secs) {
  const m = Math.floor(secs / 60), s = secs % 60;
  return String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0');
}
function fmtTime(iso) {
  if (!iso) return 'â€”';
  return new Date(iso).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

function updateArrow(i) {
  const tomato = document.querySelectorAll('.tomato')[i];
  const row    = document.getElementById('tomato-row');
  if (!tomato || !row) return;
  const x = tomato.offsetLeft + tomato.offsetWidth / 2 - row.offsetLeft;
  document.getElementById('pomo-detail').style.setProperty('--arrow-x', x + 'px');
}

function closePomoDetail() {
  detailIndex = null;
  document.querySelectorAll('.tomato.active').forEach(t => t.classList.remove('active'));
  document.getElementById('tomato-row').classList.remove('detail-open');
  const d = document.getElementById('pomo-detail');
  d.classList.remove('visible');
  d.innerHTML = '';
}

function showPomoDetail(i) {
  const prev = detailIndex;
  closePomoDetail();
  if (prev === i) return; /* tap same tomato â†’ just close */

  detailIndex = i;
  const entry = log[i];
  document.querySelectorAll('.tomato')[i].classList.add('active');
  document.getElementById('tomato-row').classList.add('detail-open');

  const icon     = entry.type === 'break' ? SVG_SQUARE : entry.skipped ? SVG_HALF_CIRCLE : SVG_CIRCLE;
  const status   = entry.type === 'break' ? 'break' : entry.skipped ? 'skipped' : 'completed';
  const duration = fmtDur(entry.durationSecs ?? 0);
  const timeStr  = fmtTime(entry.startedAt) + ' â†’ ' + fmtTime(entry.endedAt);

  const d = document.getElementById('pomo-detail');
  d.innerHTML =
    '<span class="detail-label">' + icon + (entry.label ? ' ' + entry.label : '') + '</span><br>' +
    status + ' &nbsp;Â·&nbsp; ' + duration + ' &nbsp;Â·&nbsp; ' + timeStr;
  d.classList.add('visible');
  updateArrow(i);
}

document.addEventListener('click', () => { resumeAudio(); closePomoDetail(); });

function renderLog() {
  /* only close if the selected entry no longer exists (e.g. log cleared) */
  if (detailIndex !== null && detailIndex >= log.length) closePomoDetail();

  const row = document.getElementById('tomato-row');
  row.innerHTML = '';
  log.forEach((entry, i) => {
    const span = document.createElement('span');
    span.className   = 'tomato';
    if (i === detailIndex) span.classList.add('active');
    span.innerHTML = entry.type === 'break' ? SVG_SQUARE : entry.skipped ? SVG_HALF_CIRCLE : SVG_CIRCLE;
    /* hover title */
    const parts = [];
    if (entry.label)   parts.push(entry.label);
    if (entry.skipped) parts.push('skipped');
    if (entry.endedAt) parts.push(fmtTime(entry.endedAt));
    if (parts.length)  span.title = parts.join(' Â· ');
    span.addEventListener('click', e => { e.stopPropagation(); showPomoDetail(i); });
    row.appendChild(span);
  });
  /* reposition arrow if panel is still open */
  if (detailIndex !== null && detailIndex < log.length) updateArrow(detailIndex);
}

function renderAutoStartBtn() {
  const states = { off: 'off', breaks: 'breaks', on: 'on' };
  document.getElementById('autostart-btn').innerHTML = '<kbd>a</kbd> auto-start: ' + states[autoStartMode];
}

function renderSoundBtn() {
  document.getElementById('btn-sound').innerHTML = '<kbd>m</kbd> sound: ' + soundMode;
}

function renderLogBreaksBtn() {
  document.getElementById('btn-logbreaks').innerHTML = '<kbd>b</kbd> log breaks: ' + (logBreaks ? 'on' : 'off');
}

function renderWorkoutBtn() {
  document.getElementById('btn-workout').innerHTML = workoutMode
    ? '<kbd>w</kbd> workout: on'
    : '<kbd>w</kbd> workout: off';
}

/* â”€â”€ Workout complete â”€â”€ */
function workoutComplete() {
  pause();
  workoutIndex = 0;
  isFocus      = true;
  isLongBreak  = false;
  secondsLeft  = focusSecs;
  labelInput.value = '';
  resizeLabelInput(); saveLabel();
  document.getElementById('session-label').textContent = 'workout done';
  renderCountdown(); updateTitle();
}

/* â”€â”€ Workout modal â”€â”€ */
let workoutModalOpen       = false;
let workoutModalWasRunning = false;
let workoutDraft           = [];

function renderWorkoutTaskList() {
  const container = document.getElementById('workout-task-list');
  container.innerHTML = '';
  workoutDraft.forEach((task, i) => {
    const row = document.createElement('div');
    row.className = 'workout-task-row';

    const input = document.createElement('input');
    input.type        = 'text';
    input.value       = task;
    input.placeholder = 'Exercise name';
    input.addEventListener('input', () => {
      workoutDraft[i] = input.value;
      renderWorkoutSummary(workoutDraft);
    });
    input.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault(); e.stopPropagation();
        if (i === workoutDraft.length - 1) {
          workoutDraft.push('');
          renderWorkoutTaskList();
        }
        setTimeout(() => {
          const inputs = document.querySelectorAll('#workout-task-list .workout-task-row input');
          if (inputs[i + 1]) inputs[i + 1].focus();
        }, 0);
      }
    });

    const removeBtn = document.createElement('button');
    removeBtn.className   = 'workout-task-remove';
    removeBtn.textContent = 'Ã—';
    removeBtn.addEventListener('click', () => {
      workoutDraft.splice(i, 1);
      renderWorkoutTaskList();
      renderWorkoutSummary(workoutDraft);
    });

    row.appendChild(input);
    row.appendChild(removeBtn);
    container.appendChild(row);
  });
}

function renderWorkoutSummary(draftTasks) {
  const n  = draftTasks.filter(t => t.trim().length > 0).length;
  const el = document.getElementById('workout-summary');
  if (n === 0) { el.textContent = 'No exercises'; return; }
  const noLB = document.getElementById('workout-no-longbreak-check').checked;
  let totalSecs = n * focusSecs;
  if (noLB || longBreakSecs === null || longBreakFreq === 0) {
    totalSecs += n * breakSecs;
  } else {
    const longBreaks = Math.floor(n / longBreakFreq);
    totalSecs += longBreaks * longBreakSecs + (n - longBreaks) * breakSecs;
  }
  const h = Math.floor(totalSecs / 3600);
  const m = Math.floor((totalSecs % 3600) / 60);
  let dur = '';
  if (h > 0) dur += h + 'h ';
  dur += m + 'm';
  el.textContent = n + ' exercise' + (n === 1 ? '' : 's') + ' Â· ~' + dur.trim() + ' total';
}

function openWorkoutModal() {
  workoutModalWasRunning = isRunning;
  if (isRunning) pause();
  workoutModalOpen = true;
  modalOpen        = true;
  workoutDraft     = [...workoutTasks];
  if (workoutDraft.length === 0) workoutDraft.push('');
  document.getElementById('workout-no-longbreak-check').checked = workoutNoLongBreak;
  renderWorkoutTaskList();
  renderWorkoutSummary(workoutDraft);
  document.getElementById('workout-deactivate').style.display = workoutMode ? '' : 'none';
  document.getElementById('workout-modal').classList.add('visible');
  setTimeout(() => {
    const first = document.querySelector('#workout-task-list .workout-task-row input');
    if (first) first.focus();
  }, 0);
}

function closeWorkoutModal() {
  workoutModalOpen = false;
  modalOpen        = false;
  document.getElementById('workout-modal').classList.remove('visible');
  if (workoutModalWasRunning) { workoutModalWasRunning = false; start(); }
}

function saveWorkoutModal() {
  workoutTasks       = workoutDraft.map(t => t.trim()).filter(t => t.length > 0);
  workoutMode        = workoutTasks.length > 0;
  workoutIndex       = 0;
  workoutNoLongBreak = document.getElementById('workout-no-longbreak-check').checked;
  saveWorkoutTasks(); saveWorkoutMode(); saveWorkoutNoLongBreak();
  if (workoutMode) {
    isFocus      = true;
    isLongBreak  = false;
    secondsLeft  = focusSecs;
    labelInput.value = workoutTasks[0];
    resizeLabelInput(); saveLabel();
    renderCountdown(); updateTitle();
  }
  renderSessionLabel();
  renderWorkoutBtn();
  workoutModalWasRunning = false;
  closeWorkoutModal();
}

document.getElementById('workout-save').addEventListener('click', saveWorkoutModal);
document.getElementById('workout-cancel').addEventListener('click', closeWorkoutModal);
document.getElementById('workout-deactivate').addEventListener('click', () => {
  workoutMode  = false;
  workoutIndex = 0;
  saveWorkoutMode();
  labelInput.value = '';
  resizeLabelInput(); saveLabel();
  renderSessionLabel();
  renderWorkoutBtn();
  workoutModalWasRunning = false;
  closeWorkoutModal();
});
document.getElementById('workout-modal').addEventListener('click', e => {
  if (e.target === document.getElementById('workout-modal')) closeWorkoutModal();
});
document.getElementById('workout-no-longbreak-check').addEventListener('change', () => {
  renderWorkoutSummary(workoutDraft);
});
document.getElementById('workout-add-btn').addEventListener('click', () => {
  workoutDraft.push('');
  renderWorkoutTaskList();
  setTimeout(() => {
    const inputs = document.querySelectorAll('#workout-task-list .workout-task-row input');
    if (inputs[inputs.length - 1]) inputs[inputs.length - 1].focus();
  }, 0);
});
document.getElementById('btn-workout').addEventListener('click', openWorkoutModal);

/* â”€â”€ Log-breaks toggle â”€â”€ */
document.getElementById('btn-logbreaks').addEventListener('click', () => {
  logBreaks = !logBreaks;
  saveLogBreaks();
  renderLogBreaksBtn();
});

/* â”€â”€ Auto-start toggle (cycles: off â†’ breaks â†’ on â†’ off) â”€â”€ */
document.getElementById('autostart-btn').addEventListener('click', () => {
  autoStartMode = autoStartMode === 'off' ? 'breaks' : autoStartMode === 'breaks' ? 'on' : 'off';
  saveAutoStart();
  renderAutoStartBtn();
});

/* â”€â”€ Timer modal â”€â”€ */
let modalOpen       = false;
let modalWasRunning = false;

function secsToMmSs(secs) {
  const m = Math.floor(secs / 60);
  const s = secs % 60;
  return String(m).padStart(2, '0') + ':' + String(s).padStart(2, '0');
}

function parseMmSs(str) {
  if (!str || !str.trim()) return null;
  const trimmed = str.trim();
  if (/^\d+s$/i.test(trimmed)) {
    const s = parseInt(trimmed, 10);
    if (!isNaN(s) && s > 0) return s;
  }
  const parts = trimmed.split(':');
  if (parts.length === 2) {
    const m = parseInt(parts[0], 10);
    const s = parseInt(parts[1], 10);
    if (!isNaN(m) && !isNaN(s) && s < 60 && (m > 0 || s > 0)) return m * 60 + s;
  } else if (parts.length === 1) {
    const m = parseInt(parts[0], 10);
    if (!isNaN(m) && m > 0) return m * 60;
  }
  return null;
}

function openTimerModal() {
  modalWasRunning = isRunning;
  if (isRunning) pause();
  modalOpen = true;
  document.getElementById('focus-input').value          = secsToMmSs(focusSecs);
  document.getElementById('break-input').value          = secsToMmSs(breakSecs);
  document.getElementById('longbreak-input').value      = longBreakSecs !== null ? secsToMmSs(longBreakSecs) : '';
  document.getElementById('longbreak-freq-input').value = String(longBreakFreq);
  document.getElementById('timer-modal').classList.add('visible');
  setTimeout(() => {
    const fi = document.getElementById('focus-input');
    fi.focus(); fi.select();
  }, 0);
}

function closeTimerModal() {
  modalOpen = false;
  document.getElementById('timer-modal').classList.remove('visible');
  if (modalWasRunning) { modalWasRunning = false; start(); }
}

function saveTimerModal() {
  const f    = parseMmSs(document.getElementById('focus-input').value);
  const b    = parseMmSs(document.getElementById('break-input').value);
  const lb   = parseMmSs(document.getElementById('longbreak-input').value);
  const lbfv = parseInt(document.getElementById('longbreak-freq-input').value.trim(), 10);
  if (f)  focusSecs     = f;
  if (b)  breakSecs     = b;
  longBreakSecs = lb || null; /* empty/invalid â†’ disabled */
  if (!isNaN(lbfv) && lbfv >= 0) longBreakFreq = lbfv;
  saveDurations();
  secondsLeft = isFocus ? focusSecs : (isLongBreak ? longBreakSecs ?? breakSecs : breakSecs);
  renderCountdown();
  updateTitle();
  modalWasRunning = false;
  modalOpen = false;
  document.getElementById('timer-modal').classList.remove('visible');
}

document.getElementById('modal-save').addEventListener('click', saveTimerModal);
document.getElementById('modal-cancel').addEventListener('click', closeTimerModal);
document.getElementById('modal-reset').addEventListener('click', () => {
  document.getElementById('focus-input').value          = '25:00';
  document.getElementById('break-input').value          = '05:00';
  document.getElementById('longbreak-input').value      = '20:00';
  document.getElementById('longbreak-freq-input').value = '4';
});
document.getElementById('timer-modal').addEventListener('click', e => {
  if (e.target === document.getElementById('timer-modal')) closeTimerModal();
});

/* Submit modal on Enter â€” stopPropagation prevents the global handler from also firing */
['focus-input', 'break-input', 'longbreak-input', 'longbreak-freq-input'].forEach(id => {
  document.getElementById(id).addEventListener('keydown', e => {
    if (e.key === 'Enter') { e.preventDefault(); e.stopPropagation(); saveTimerModal(); }
  });
});

/* â”€â”€ Fullscreen â”€â”€ */
function toggleFullscreen() {
  const el  = document.documentElement;
  const isFs = document.fullscreenElement || document.webkitFullscreenElement;
  if (!isFs) {
    (el.requestFullscreen || el.webkitRequestFullscreen).call(el);
  } else {
    (document.exitFullscreen || document.webkitExitFullscreen).call(document);
  }
}

/* â”€â”€ Export to .ics â”€â”€ */
function toICSDate(date) {
  /* "2026-02-20T10:00:00.000Z" â†’ "20260220T100000Z" */
  return date.toISOString().replace(/[-:]/g, '').replace(/\.\d{3}/, '');
}

function exportICS() {
  const entries = log.filter(e => e.startedAt && e.endedAt);
  if (entries.length === 0) { labelInput.value = 'Focus first.'; saveLabel(); resizeLabelInput(); return; }

  const lines = [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'PRODID:-//moltaire//Pomodoro//EN',
    'CALSCALE:GREGORIAN',
  ];

  entries.forEach((entry, i) => {
    let summary;
    if (entry.type === 'break') {
      summary = 'ðŸŸ¦ Break';
    } else if (entry.skipped) {
      summary = 'ðŸŸ¡' + (entry.label ? ' ' + entry.label : ' Focus session');
    } else {
      summary = 'ðŸ”´' + (entry.label ? ' ' + entry.label : ' Focus session');
    }
    lines.push('BEGIN:VEVENT');
    lines.push('UID:pomo-' + i + '-' + entry.startedAt + '@pomodoro');
    lines.push('DTSTART:' + toICSDate(new Date(entry.startedAt)));
    lines.push('DTEND:'   + toICSDate(new Date(entry.endedAt)));
    lines.push('SUMMARY:' + summary);
    lines.push('END:VEVENT');
  });

  lines.push('END:VCALENDAR');

  const blob = new Blob([lines.join('\r\n')], { type: 'text/calendar' });
  const a    = document.createElement('a');
  a.href     = URL.createObjectURL(blob);
  a.download = 'pomodoro.ics';
  a.click();
  URL.revokeObjectURL(a.href);
}

/* â”€â”€ Label input â”€â”€ */
const labelInput = document.getElementById('label-input');

function resizeLabelInput() {
  labelInput.style.height = 'auto';
  labelInput.style.height = labelInput.scrollHeight + 'px';
}

labelInput.addEventListener('input', () => { saveLabel(); resizeLabelInput(); });

/* Strip newlines on paste so the label stays logically single-line */
labelInput.addEventListener('paste', e => {
  e.preventDefault();
  const text = (e.clipboardData || window.clipboardData).getData('text/plain').replace(/[\r\n]+/g, ' ');
  const s = labelInput.selectionStart, end = labelInput.selectionEnd;
  labelInput.value = labelInput.value.slice(0, s) + text + labelInput.value.slice(end);
  labelInput.selectionStart = labelInput.selectionEnd = s + text.length;
  saveLabel(); resizeLabelInput();
});

document.addEventListener('keydown', e => {
  resumeAudio();
  if (e.metaKey || e.ctrlKey || e.altKey) return;

  if (e.key === 'Escape') {
    if (workoutModalOpen) { closeWorkoutModal(); return; }
    if (modalOpen) { closeTimerModal(); return; }
    if (document.activeElement === labelInput) { labelInput.blur(); return; }
    return;
  }

  if (modalOpen) return;

  const inLabel = document.activeElement === labelInput;

  /* Enter: toggle label focus */
  if (e.key === 'Enter') {
    e.preventDefault();
    if (inLabel) labelInput.blur();
    else         labelInput.focus();
    return;
  }

  if (inLabel) return;

  if (e.key === ' ')                  { e.preventDefault(); isRunning ? pause() : start(); }
  if (e.key === 's' || e.key === 'S') skip();
  if (e.key === 'r' || e.key === 'R') reset();
  if (e.key === 'd' || e.key === 'D') { e.preventDefault(); openTimerModal(); }
  if (e.key === 'c' || e.key === 'C') { log = []; focusSessionCount = 0; saveLog(); saveFocusCount(); renderLog(); }
  if (e.key === 'e' || e.key === 'E') exportICS();
  if (e.key === 'Backspace')          { e.preventDefault(); labelInput.value = ''; saveLabel(); resizeLabelInput(); }
  if (e.key === 'a' || e.key === 'A') {
    autoStartMode = autoStartMode === 'off' ? 'breaks' : autoStartMode === 'breaks' ? 'on' : 'off';
    saveAutoStart(); renderAutoStartBtn();
  }
  if (e.key === 'm' || e.key === 'M') {
    soundMode = soundMode === 'on' ? 'finish' : soundMode === 'finish' ? 'off' : 'on';
    saveSound(); renderSoundBtn();
  }
  if (e.key === 'b' || e.key === 'B') { logBreaks = !logBreaks; saveLogBreaks(); renderLogBreaksBtn(); }
  if (e.key === 'f' || e.key === 'F') toggleFullscreen();
  if (e.key === 'w' || e.key === 'W') openWorkoutModal();
  if (e.key === 'h' || e.key === 'H') toggleHints();
});

/* â”€â”€ Countdown click â”€â”€ */
/* â”€â”€ Hints toggle â”€â”€ */
let hintsHidden = false;
function toggleHints() {
  hintsHidden = !hintsHidden;
  document.querySelector('.instructions').style.display = hintsHidden ? 'none' : '';
}
document.body.addEventListener('dblclick', e => {
  if (e.target === document.body) toggleHints();
});

document.getElementById('countdown').addEventListener('click', () => { isRunning ? pause() : start(); });

/* â”€â”€ Button click listeners â”€â”€ */
document.getElementById('btn-playpause').addEventListener('click', () => { isRunning ? pause() : start(); });
document.getElementById('btn-skip').addEventListener('click', skip);
document.getElementById('btn-reset').addEventListener('click', reset);
document.getElementById('btn-durations').addEventListener('click', openTimerModal);
document.getElementById('btn-label').addEventListener('click', () => {
  if (document.activeElement === labelInput) labelInput.blur(); else labelInput.focus();
});
document.getElementById('btn-clearlabel').addEventListener('click', () => { labelInput.value = ''; saveLabel(); resizeLabelInput(); });
document.getElementById('btn-clearlog').addEventListener('click', () => { log = []; focusSessionCount = 0; saveLog(); saveFocusCount(); renderLog(); });
document.getElementById('btn-export').addEventListener('click', exportICS);
document.getElementById('btn-sound').addEventListener('click', () => {
  soundMode = soundMode === 'on' ? 'finish' : soundMode === 'finish' ? 'off' : 'on';
  saveSound(); renderSoundBtn();
});
document.getElementById('btn-fullscreen').addEventListener('click', toggleFullscreen);

/* â”€â”€ Init â”€â”€ */
loadDurations();
secondsLeft = focusSecs;
loadLog();
loadLabel();
loadAutoStart();
loadSound();
loadLogBreaks();
loadWorkoutTasks();
loadWorkoutMode();
loadWorkoutNoLongBreak();
loadFocusCount();
renderLog();
renderAutoStartBtn();
renderSoundBtn();
renderLogBreaksBtn();
renderWorkoutBtn();
renderSessionLabel();
if (workoutMode && workoutTasks.length) {
  labelInput.value = workoutTasks[0];
  resizeLabelInput();
}
renderCountdown();
updateTitle();

</script>
</body>
</html>
