<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
  <link id="page-favicon" rel="icon" href="" />
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>00:05</title>

  <style>
    :root {
      --bg:     #1c1b22;
      --card:   #2b2a32;
      --card2:  #27262e;
      --text:   #e5e5e5;
      --dim:    #7c7884;
      --accent: #757c58;
      --radius: 12px;
    }

    body {
      margin: 0;
      background: var(--bg);
      font-family: Inter, Arial, sans-serif;
      color: var(--text);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 40px;
      margin-top: clamp(12px, 6vh, 100px);
    }

    .page-wrap { width: 80%; max-width: 950px; margin: 0 auto; }

    #session-label {
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--dim);
      width: 80%;
      max-width: 950px;
      margin: 0 0 2px;
      line-height: 1;
    }

    #timer-row {
      display: flex;
      align-items: baseline;
      gap: 16px;
      width: 80%;
      max-width: 950px;
      margin: 0 0 28px;
    }

    #countdown {
      font-size: 4.5rem;
      font-weight: 600;
      letter-spacing: -3px;
      line-height: 1;
      flex-shrink: 0;
      font-variant-numeric: tabular-nums;
      cursor: pointer;
      user-select: none;
    }

    #label-input {
      flex: 1;
      min-width: 0;
      background: transparent;
      border: none;
      outline: none;
      font-family: Inter, Arial, sans-serif;
      font-size: 4.5rem;
      font-weight: 600;
      letter-spacing: -3px;
      color: var(--dim);
      padding: 0;
      line-height: 1;
      padding-bottom: 0.15em;
      caret-color: var(--dim);
      resize: none;
      overflow: hidden;
      word-break: break-word;
      -webkit-appearance: none;
      appearance: none;
    }

    #label-input::placeholder { color: rgba(255,255,255,0.01); }
    #label-input:focus::placeholder { opacity: 0; }

    #tomato-row {
      width: 100%;
      margin: 0 0 28px;
      font-size: 1.4rem;
      line-height: 1.6;
      min-height: 2.25rem;
    }
    #tomato-row.detail-open { margin-bottom: 6px; }

    .tomato { cursor: pointer; padding: 2px; border-radius: 4px; }
    .tomato.active { background: var(--card); }

    #pomo-detail {
      display: none;
      background: var(--card);
      border-radius: var(--radius);
      padding: 10px 14px;
      margin-bottom: 22px;
      font-size: 0.78rem;
      color: var(--dim);
      line-height: 1.7;
    }
    #pomo-detail.visible { display: block; }
    #pomo-detail .detail-label { color: var(--text); font-weight: 500; }

    .instructions {
      color: var(--dim);
      font-size: 0.72rem;
      line-height: 1.9;
    }

    kbd {
      background: #18171e;
      color: #b6b3bc;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.7rem;
      font-family: Inter, monospace;
    }

    .reset-btn {
      background: none;
      border: none;
      color: var(--dim);
      font-family: Inter, sans-serif;
      font-size: 0.72rem;
      cursor: pointer;
      padding: 0;
    }
    .reset-btn:hover { color: var(--text); }

    /* ‚îÄ‚îÄ Timer modal ‚îÄ‚îÄ */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    .modal-overlay.visible { display: flex; }

    .modal {
      background: var(--card);
      border-radius: var(--radius);
      padding: 28px 32px;
      min-width: 300px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
    }

    .modal-title {
      margin: 0 0 20px;
      font-size: 1rem;
      font-weight: 600;
      color: var(--text);
    }

    .modal-row {
      display: flex;
      gap: 12px;
      margin-bottom: 20px;
    }

    .modal-field { flex: 1; }

    .modal-field label {
      display: block;
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.07em;
      text-transform: uppercase;
      color: var(--dim);
      margin-bottom: 6px;
    }

    .modal-field input {
      width: 100%;
      background: var(--card2);
      border: 1px solid #44435a;
      border-radius: 8px;
      padding: 9px 12px;
      font-size: 0.9rem;
      font-family: Inter, sans-serif;
      color: var(--text);
      outline: none;
      box-sizing: border-box;
    }
    .modal-field input:focus { border-color: var(--accent); }

    .modal-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .modal-actions button {
      background: var(--card2);
      border: 1px solid #44435a;
      border-radius: 8px;
      padding: 9px 20px;
      font-size: 0.88rem;
      font-family: Inter, sans-serif;
      color: var(--text);
      cursor: pointer;
    }
    .modal-actions button:hover { border-color: var(--accent); }

    .modal-actions .modal-save-btn {
      background: #a8b86a;
      border-color: #a8b86a;
      color: #1c1b22;
      font-weight: 600;
    }
    .modal-actions .modal-save-btn:hover { background: #bccf7a; border-color: #bccf7a; color: #0e0d14; }

    /* ‚îÄ‚îÄ Narrow screens: stack label below timer ‚îÄ‚îÄ */
    @media (max-width: 540px) {
      #timer-row { display: block; }
      #label-input { display: block; width: 100%; box-sizing: border-box; font-size: 2rem; letter-spacing: -1px; }
    }

    /* ‚îÄ‚îÄ GitHub link ‚îÄ‚îÄ */
    .gh-link {
      position: fixed;
      bottom: 14px;
      right: 18px;
      font-size: 0.68rem;
      color: var(--dim);
      text-decoration: none;
      opacity: 0.45;
      transition: opacity 0.15s;
    }
    .gh-link:hover { opacity: 1; }
  </style>
</head>

<body>

  <div id="session-label">focus</div>
  <div id="timer-row">
    <div id="countdown">00:05</div>
    <textarea id="label-input" autocomplete="off" spellcheck="false" placeholder="‚ñå" rows="1"></textarea>
  </div>

  <div class="page-wrap">
    <div id="tomato-row"></div>
    <div id="pomo-detail"></div>
    <div class="instructions">
      <button class="reset-btn" id="btn-playpause"><kbd>Space</kbd> start/pause</button> &nbsp;¬∑&nbsp;
      <button class="reset-btn" id="btn-skip"><kbd>s</kbd> skip</button> &nbsp;¬∑&nbsp;
      <button class="reset-btn" id="btn-reset"><kbd>r</kbd> reset</button> &nbsp;¬∑&nbsp;
      <button class="reset-btn" id="btn-label"><kbd>‚Üµ</kbd> edit label</button> &nbsp;¬∑&nbsp;
      <button class="reset-btn" id="btn-clearlabel"><kbd>del</kbd> clear label</button><br>
      <button class="reset-btn" id="btn-export"><kbd>e</kbd> export</button> &nbsp;¬∑&nbsp;
      <button class="reset-btn" id="btn-clearlog"><kbd>c</kbd> clear log</button> &nbsp;¬∑&nbsp;
      <button class="reset-btn" id="btn-durations"><kbd>d</kbd> durations</button> &nbsp;¬∑&nbsp;
      <button class="reset-btn" id="autostart-btn">auto-start: breaks</button> &nbsp;¬∑&nbsp;
      <button class="reset-btn" id="btn-sound"><kbd>m</kbd> sound: on</button><br>
      <button class="reset-btn" id="btn-fullscreen"><kbd>f</kbd> fullscreen</button>
    </div>
  </div>

  <div class="modal-overlay" id="timer-modal">
    <div class="modal">
      <p class="modal-title">Set durations</p>
      <div class="modal-row">
        <div class="modal-field">
          <label for="focus-input">Focus</label>
          <input id="focus-input" type="text" placeholder="25:00" />
        </div>
        <div class="modal-field">
          <label for="break-input">Break</label>
          <input id="break-input" type="text" placeholder="05:00" />
        </div>
        <div class="modal-field">
          <label for="longbreak-input">Long break</label>
          <input id="longbreak-input" type="text" placeholder="‚Äî" />
        </div>
      </div>
      <div class="modal-actions">
        <button id="modal-reset">Reset</button>
        <button id="modal-cancel">Cancel</button>
        <button class="modal-save-btn" id="modal-save">Set</button>
      </div>
    </div>
  </div>

  <a class="gh-link" href="https://github.com/moltaire/pomodoro" target="_blank" rel="noopener">github</a>

<script>

let focusSecs     = 25 * 60;
let breakSecs     = 5  * 60;
let longBreakSecs = 20 * 60; // null = disabled; number = seconds for every 4th break

/* ‚îÄ‚îÄ Sound ‚îÄ‚îÄ */
let soundMode = 'on';  // 'on' | 'finish' | 'off'
let audioCtx  = null;

function getAudioCtx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

/* iOS Safari keeps AudioContext suspended until a user gesture explicitly resumes it.
   Create the context here (not lazily on first sound) so that the very first tap/key
   both creates AND unlocks it while we're still inside the user-gesture callback.
   Also play a silent <Audio> element once to promote the iOS audio session from
   "ambient" (respects mute switch) to "playback" (ignores mute switch). */
let _iosAudioUnlocked = false;
function resumeAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
  if (!_iosAudioUnlocked) {
    _iosAudioUnlocked = true;
    const a = new Audio('data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=');
    a.play().catch(() => {});
  }
}

/* Metronome tick: short noise burst with power-law decay (~20 ms) */
function playTick() {
  const ctx  = getAudioCtx();
  const len  = Math.floor(ctx.sampleRate * 0.02);
  const buf  = ctx.createBuffer(1, len, ctx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < len; i++)
    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 6);
  const src  = ctx.createBufferSource();
  const gain = ctx.createGain();
  gain.gain.value = 0.35;
  src.buffer = buf;
  src.connect(gain);
  gain.connect(ctx.destination);
  src.start();
}

/* Session-end clave: two quick sine taps at 1400 / 1600 Hz */
function playDone() {
  const ctx = getAudioCtx();
  [0, 0.08].forEach((offset, i) => {
    const osc  = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.frequency.value = 1400 + i * 200;
    const t = ctx.currentTime + offset;
    gain.gain.setValueAtTime(0.4, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.07);
    osc.start(t);
    osc.stop(t + 0.07);
  });
}

/* ‚îÄ‚îÄ State ‚îÄ‚îÄ */
let isFocus          = true;
let isLongBreak      = false;
let secondsLeft      = focusSecs;
let isRunning        = false;
let timerId          = null;
let sessionStartTime = null; // ISO string, set when a focus session begins
let autoStartMode    = 'breaks'; // 'off' | 'breaks' | 'on'
let log              = [];
// log entry: { label: string|null, startedAt: ISO|null, endedAt: ISO, durationSecs: number }

/* ‚îÄ‚îÄ localStorage ‚îÄ‚îÄ */
function lsGet(k) { try { return localStorage.getItem(k); } catch { return null; } }
function lsSet(k, v) { try { localStorage.setItem(k, v); } catch {} }

function saveLog()       { lsSet('pomo_log2',           JSON.stringify(log)); }
function saveLabel()     { lsSet('pomo_label',           labelInput.value); }
function saveAutoStart() { lsSet('pomo_autostart',       autoStartMode); }
function saveSound()     { lsSet('pomo_sound',           soundMode); }
function saveDurations() {
  lsSet('pomo_focus_secs',     String(focusSecs));
  lsSet('pomo_break_secs',     String(breakSecs));
  lsSet('pomo_long_break_secs', longBreakSecs !== null ? String(longBreakSecs) : '');
}

function loadLog() {
  try { log = JSON.parse(lsGet('pomo_log2')) || []; } catch { log = []; }
}
function loadLabel() {
  labelInput.value = lsGet('pomo_label') || '';
  resizeLabelInput();
}
function loadAutoStart() {
  const v = lsGet('pomo_autostart');
  autoStartMode = (v === 'on' || v === 'off' || v === 'breaks') ? v : 'breaks';
}
function loadSound() {
  const v = lsGet('pomo_sound');
  soundMode = (v === 'finish' || v === 'off') ? v : 'on';
}
function loadDurations() {
  const f  = parseInt(lsGet('pomo_focus_secs'),      10);
  const b  = parseInt(lsGet('pomo_break_secs'),      10);
  const lb = parseInt(lsGet('pomo_long_break_secs'), 10);
  if (!isNaN(f)  && f  > 0) focusSecs     = f;
  if (!isNaN(b)  && b  > 0) breakSecs     = b;
  if (!isNaN(lb) && lb > 0) longBreakSecs = lb;
}

/* ‚îÄ‚îÄ Timer ‚Äî setTimeout-based for reliability ‚îÄ‚îÄ */
function start() {
  if (isRunning) return;
  /* record when this focus session begins (first start, not resume) */
  if (isFocus && sessionStartTime === null) {
    sessionStartTime = new Date().toISOString();
  }
  isRunning = true;
  timerId   = setTimeout(tick, 1000);
}

function pause() {
  if (!isRunning) return;
  isRunning = false;
  clearTimeout(timerId);
  timerId = null;
}

function tick() {
  if (!isRunning) return;
  secondsLeft--;
  if (soundMode === 'on' && isFocus) playTick();
  renderCountdown();
  updateTitle();
  if (secondsLeft <= 0) {
    onSessionEnd();
  } else {
    timerId = setTimeout(tick, 1000);
  }
}

function onSessionEnd() {
  isRunning = false;
  timerId   = null;
  if (soundMode === 'on' || soundMode === 'finish') playDone();

  if (isFocus) {
    const endedAt = new Date().toISOString();
    log.push({
      label:       labelInput.value.trim() || null,
      startedAt:   sessionStartTime,
      endedAt,
      durationSecs: focusSecs,
    });
    sessionStartTime = null;
    saveLog();
    renderLog();
  }

  isFocus = !isFocus;

  if (!isFocus) {
    /* entering a break ‚Äî every 4th focus completion is a long break */
    isLongBreak = longBreakSecs !== null && log.length % 4 === 0;
    secondsLeft = isLongBreak ? longBreakSecs : breakSecs;
  } else {
    isLongBreak = false;
    secondsLeft = focusSecs;
  }

  renderSessionLabel();
  renderCountdown();
  updateTitle();

  /* auto-start: 'on' always starts; 'breaks' only starts when entering a break */
  const entering = isFocus ? 'focus' : 'break';
  if (autoStartMode === 'on' || (autoStartMode === 'breaks' && entering === 'break')) {
    setTimeout(start, 100);
  }
}

function reset() {
  pause();
  sessionStartTime = null;
  secondsLeft = isFocus ? focusSecs : (isLongBreak ? longBreakSecs : breakSecs);
  renderCountdown();
  updateTitle();
}

function skip() {
  const wasRunning = isRunning;
  pause();

  /* log skipped focus session (peach) if it was actually started */
  if (isFocus && sessionStartTime !== null) {
    const endedAt = new Date().toISOString();
    log.push({
      label:       labelInput.value.trim() || null,
      startedAt:   sessionStartTime,
      endedAt,
      durationSecs: focusSecs - secondsLeft,
      skipped:     true,
    });
    saveLog();
    renderLog();
  }

  sessionStartTime = null;
  isFocus     = !isFocus;
  isLongBreak = false; /* skips don't trigger long break */
  secondsLeft = isFocus ? focusSecs : breakSecs;
  renderSessionLabel();
  renderCountdown();
  updateTitle();
  const entering = isFocus ? 'focus' : 'break';
  if (wasRunning || autoStartMode === 'on' || (autoStartMode === 'breaks' && entering === 'break')) {
    start();
  }
}

/* ‚îÄ‚îÄ Render ‚îÄ‚îÄ */
function renderSessionLabel() {
  const el = document.getElementById('session-label');
  if      (isFocus)      el.textContent = 'focus';
  else if (isLongBreak)  el.textContent = 'long break';
  else                   el.textContent = 'break';
}

function renderCountdown() {
  const m = Math.floor(secondsLeft / 60);
  const s = secondsLeft % 60;
  document.getElementById('countdown').textContent =
    String(m).padStart(2, '0') + ':' + String(s).padStart(2, '0');
}

function _setFaviconEmoji(emoji) {
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">${emoji}</text></svg>`;
  const href = 'data:image/svg+xml,' + encodeURIComponent(svg);
  const old = document.getElementById('page-favicon');
  const link = document.createElement('link');
  link.id = 'page-favicon';
  link.rel = 'icon';
  link.href = href;
  document.head.replaceChild(link, old);
}
_setFaviconEmoji('üçÖ');

function updateTitle() {
  const m = Math.floor(secondsLeft / 60);
  const s = secondsLeft % 60;
  const t = String(m).padStart(2, '0') + ':' + String(s).padStart(2, '0');
  document.title = t;
  _setFaviconEmoji(isFocus ? 'üçÖ' : '‚òï');
}

/* ‚îÄ‚îÄ Pomo detail panel ‚îÄ‚îÄ */
let detailIndex = null;

function fmtDur(secs) {
  const m = Math.floor(secs / 60), s = secs % 60;
  return String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0');
}
function fmtTime(iso) {
  if (!iso) return '‚Äî';
  return new Date(iso).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

function updateArrow(i) {
  const tomato = document.querySelectorAll('.tomato')[i];
  const row    = document.getElementById('tomato-row');
  if (!tomato || !row) return;
  const x = tomato.offsetLeft + tomato.offsetWidth / 2 - row.offsetLeft;
  document.getElementById('pomo-detail').style.setProperty('--arrow-x', x + 'px');
}

function closePomoDetail() {
  detailIndex = null;
  document.querySelectorAll('.tomato.active').forEach(t => t.classList.remove('active'));
  document.getElementById('tomato-row').classList.remove('detail-open');
  const d = document.getElementById('pomo-detail');
  d.classList.remove('visible');
  d.innerHTML = '';
}

function showPomoDetail(i) {
  const prev = detailIndex;
  closePomoDetail();
  if (prev === i) return; /* tap same tomato ‚Üí just close */

  detailIndex = i;
  const entry = log[i];
  document.querySelectorAll('.tomato')[i].classList.add('active');
  document.getElementById('tomato-row').classList.add('detail-open');

  const emoji    = entry.skipped ? 'üçë' : 'üçÖ';
  const status   = entry.skipped ? 'skipped' : 'completed';
  const duration = fmtDur(entry.durationSecs ?? 0);
  const timeStr  = fmtTime(entry.startedAt) + ' ‚Üí ' + fmtTime(entry.endedAt);

  const d = document.getElementById('pomo-detail');
  d.innerHTML =
    '<span class="detail-label">' + emoji + (entry.label ? ' ' + entry.label : '') + '</span><br>' +
    status + ' &nbsp;¬∑&nbsp; ' + duration + ' &nbsp;¬∑&nbsp; ' + timeStr;
  d.classList.add('visible');
  updateArrow(i);
}

document.addEventListener('click', () => { resumeAudio(); closePomoDetail(); });

function renderLog() {
  /* only close if the selected entry no longer exists (e.g. log cleared) */
  if (detailIndex !== null && detailIndex >= log.length) closePomoDetail();

  const row = document.getElementById('tomato-row');
  row.innerHTML = '';
  log.forEach((entry, i) => {
    const span = document.createElement('span');
    span.className   = 'tomato';
    if (i === detailIndex) span.classList.add('active');
    span.textContent = entry.skipped ? 'üçë' : 'üçÖ';
    /* hover title */
    const parts = [];
    if (entry.label)   parts.push(entry.label);
    if (entry.skipped) parts.push('skipped');
    if (entry.endedAt) parts.push(fmtTime(entry.endedAt));
    if (parts.length)  span.title = parts.join(' ¬∑ ');
    span.addEventListener('click', e => { e.stopPropagation(); showPomoDetail(i); });
    row.appendChild(span);
  });
  /* reposition arrow if panel is still open */
  if (detailIndex !== null && detailIndex < log.length) updateArrow(detailIndex);
}

function renderAutoStartBtn() {
  const states = { off: 'off', breaks: 'breaks', on: 'on' };
  document.getElementById('autostart-btn').innerHTML = '<kbd>a</kbd> auto-start: ' + states[autoStartMode];
}

function renderSoundBtn() {
  document.getElementById('btn-sound').innerHTML = '<kbd>m</kbd> sound: ' + soundMode;
}

/* ‚îÄ‚îÄ Auto-start toggle (cycles: off ‚Üí breaks ‚Üí on ‚Üí off) ‚îÄ‚îÄ */
document.getElementById('autostart-btn').addEventListener('click', () => {
  autoStartMode = autoStartMode === 'off' ? 'breaks' : autoStartMode === 'breaks' ? 'on' : 'off';
  saveAutoStart();
  renderAutoStartBtn();
});

/* ‚îÄ‚îÄ Timer modal ‚îÄ‚îÄ */
let modalOpen       = false;
let modalWasRunning = false;

function secsToMmSs(secs) {
  const m = Math.floor(secs / 60);
  const s = secs % 60;
  return String(m).padStart(2, '0') + ':' + String(s).padStart(2, '0');
}

function parseMmSs(str) {
  if (!str || !str.trim()) return null;
  const parts = str.trim().split(':');
  if (parts.length === 2) {
    const m = parseInt(parts[0], 10);
    const s = parseInt(parts[1], 10);
    if (!isNaN(m) && !isNaN(s) && s < 60 && (m > 0 || s > 0)) return m * 60 + s;
  } else if (parts.length === 1) {
    const m = parseInt(parts[0], 10);
    if (!isNaN(m) && m > 0) return m * 60;
  }
  return null;
}

function openTimerModal() {
  modalWasRunning = isRunning;
  if (isRunning) pause();
  modalOpen = true;
  document.getElementById('focus-input').value     = secsToMmSs(focusSecs);
  document.getElementById('break-input').value     = secsToMmSs(breakSecs);
  document.getElementById('longbreak-input').value = longBreakSecs !== null ? secsToMmSs(longBreakSecs) : '';
  document.getElementById('timer-modal').classList.add('visible');
  setTimeout(() => {
    const fi = document.getElementById('focus-input');
    fi.focus(); fi.select();
  }, 0);
}

function closeTimerModal() {
  modalOpen = false;
  document.getElementById('timer-modal').classList.remove('visible');
  if (modalWasRunning) { modalWasRunning = false; start(); }
}

function saveTimerModal() {
  const f  = parseMmSs(document.getElementById('focus-input').value);
  const b  = parseMmSs(document.getElementById('break-input').value);
  const lb = parseMmSs(document.getElementById('longbreak-input').value);
  if (f)  focusSecs     = f;
  if (b)  breakSecs     = b;
  longBreakSecs = lb || null; /* empty/invalid ‚Üí disabled */
  saveDurations();
  secondsLeft = isFocus ? focusSecs : (isLongBreak ? longBreakSecs ?? breakSecs : breakSecs);
  renderCountdown();
  updateTitle();
  modalWasRunning = false;
  modalOpen = false;
  document.getElementById('timer-modal').classList.remove('visible');
}

document.getElementById('modal-save').addEventListener('click', saveTimerModal);
document.getElementById('modal-cancel').addEventListener('click', closeTimerModal);
document.getElementById('modal-reset').addEventListener('click', () => {
  document.getElementById('focus-input').value     = '25:00';
  document.getElementById('break-input').value     = '05:00';
  document.getElementById('longbreak-input').value = '20:00';
});
document.getElementById('timer-modal').addEventListener('click', e => {
  if (e.target === document.getElementById('timer-modal')) closeTimerModal();
});

/* Submit modal on Enter ‚Äî stopPropagation prevents the global handler from also firing */
['focus-input', 'break-input', 'longbreak-input'].forEach(id => {
  document.getElementById(id).addEventListener('keydown', e => {
    if (e.key === 'Enter') { e.preventDefault(); e.stopPropagation(); saveTimerModal(); }
  });
});

/* ‚îÄ‚îÄ Fullscreen ‚îÄ‚îÄ */
function toggleFullscreen() {
  const el  = document.documentElement;
  const isFs = document.fullscreenElement || document.webkitFullscreenElement;
  if (!isFs) {
    (el.requestFullscreen || el.webkitRequestFullscreen).call(el);
  } else {
    (document.exitFullscreen || document.webkitExitFullscreen).call(document);
  }
}

/* ‚îÄ‚îÄ Export to .ics ‚îÄ‚îÄ */
function toICSDate(date) {
  /* "2026-02-20T10:00:00.000Z" ‚Üí "20260220T100000Z" */
  return date.toISOString().replace(/[-:]/g, '').replace(/\.\d{3}/, '');
}

function exportICS() {
  const entries = log.filter(e => e.startedAt && e.endedAt);
  if (entries.length === 0) { labelInput.value = 'Focus first.'; saveLabel(); resizeLabelInput(); return; }

  const lines = [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'PRODID:-//moltaire//Pomodoro//EN',
    'CALSCALE:GREGORIAN',
  ];

  entries.forEach((entry, i) => {
    const summary = 'üçÖ' + (entry.label ? ' ' + entry.label : ' Focus session');
    lines.push('BEGIN:VEVENT');
    lines.push('UID:pomo-' + i + '-' + entry.startedAt + '@pomodoro');
    lines.push('DTSTART:' + toICSDate(new Date(entry.startedAt)));
    lines.push('DTEND:'   + toICSDate(new Date(entry.endedAt)));
    lines.push('SUMMARY:' + summary);
    lines.push('END:VEVENT');
  });

  lines.push('END:VCALENDAR');

  const blob = new Blob([lines.join('\r\n')], { type: 'text/calendar' });
  const a    = document.createElement('a');
  a.href     = URL.createObjectURL(blob);
  a.download = 'pomodoro.ics';
  a.click();
  URL.revokeObjectURL(a.href);
}

/* ‚îÄ‚îÄ Label input ‚îÄ‚îÄ */
const labelInput = document.getElementById('label-input');

function resizeLabelInput() {
  labelInput.style.height = 'auto';
  labelInput.style.height = labelInput.scrollHeight + 'px';
}

labelInput.addEventListener('input', () => { saveLabel(); resizeLabelInput(); });

/* Strip newlines on paste so the label stays logically single-line */
labelInput.addEventListener('paste', e => {
  e.preventDefault();
  const text = (e.clipboardData || window.clipboardData).getData('text/plain').replace(/[\r\n]+/g, ' ');
  const s = labelInput.selectionStart, end = labelInput.selectionEnd;
  labelInput.value = labelInput.value.slice(0, s) + text + labelInput.value.slice(end);
  labelInput.selectionStart = labelInput.selectionEnd = s + text.length;
  saveLabel(); resizeLabelInput();
});

document.addEventListener('keydown', e => {
  resumeAudio();
  if (e.metaKey || e.ctrlKey || e.altKey) return;

  if (e.key === 'Escape') {
    if (modalOpen) { closeTimerModal(); return; }
    if (document.activeElement === labelInput) { labelInput.blur(); return; }
    return;
  }

  if (modalOpen) return;

  const inLabel = document.activeElement === labelInput;

  /* Enter: toggle label focus */
  if (e.key === 'Enter') {
    e.preventDefault();
    if (inLabel) labelInput.blur();
    else         labelInput.focus();
    return;
  }

  if (inLabel) return;

  if (e.key === ' ')                  { e.preventDefault(); isRunning ? pause() : start(); }
  if (e.key === 's' || e.key === 'S') skip();
  if (e.key === 'r' || e.key === 'R') reset();
  if (e.key === 'd' || e.key === 'D') { e.preventDefault(); openTimerModal(); }
  if (e.key === 'c' || e.key === 'C') { log = []; saveLog(); renderLog(); }
  if (e.key === 'e' || e.key === 'E') exportICS();
  if (e.key === 'Backspace')          { e.preventDefault(); labelInput.value = ''; saveLabel(); resizeLabelInput(); }
  if (e.key === 'a' || e.key === 'A') {
    autoStartMode = autoStartMode === 'off' ? 'breaks' : autoStartMode === 'breaks' ? 'on' : 'off';
    saveAutoStart(); renderAutoStartBtn();
  }
  if (e.key === 'm' || e.key === 'M') {
    soundMode = soundMode === 'on' ? 'finish' : soundMode === 'finish' ? 'off' : 'on';
    saveSound(); renderSoundBtn();
  }
  if (e.key === 'f' || e.key === 'F') toggleFullscreen();
});

/* ‚îÄ‚îÄ Countdown click ‚îÄ‚îÄ */
document.getElementById('countdown').addEventListener('click', () => { isRunning ? pause() : start(); });

/* ‚îÄ‚îÄ Button click listeners ‚îÄ‚îÄ */
document.getElementById('btn-playpause').addEventListener('click', () => { isRunning ? pause() : start(); });
document.getElementById('btn-skip').addEventListener('click', skip);
document.getElementById('btn-reset').addEventListener('click', reset);
document.getElementById('btn-durations').addEventListener('click', openTimerModal);
document.getElementById('btn-label').addEventListener('click', () => {
  if (document.activeElement === labelInput) labelInput.blur(); else labelInput.focus();
});
document.getElementById('btn-clearlabel').addEventListener('click', () => { labelInput.value = ''; saveLabel(); resizeLabelInput(); });
document.getElementById('btn-clearlog').addEventListener('click', () => { log = []; saveLog(); renderLog(); });
document.getElementById('btn-export').addEventListener('click', exportICS);
document.getElementById('btn-sound').addEventListener('click', () => {
  soundMode = soundMode === 'on' ? 'finish' : soundMode === 'finish' ? 'off' : 'on';
  saveSound(); renderSoundBtn();
});
document.getElementById('btn-fullscreen').addEventListener('click', toggleFullscreen);

/* ‚îÄ‚îÄ Init ‚îÄ‚îÄ */
loadDurations();
secondsLeft = focusSecs;
loadLog();
loadLabel();
loadAutoStart();
loadSound();
renderLog();
renderAutoStartBtn();
renderSoundBtn();
renderCountdown();
updateTitle();

</script>
</body>
</html>
